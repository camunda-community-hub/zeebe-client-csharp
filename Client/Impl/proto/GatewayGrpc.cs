// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: gateway.proto
// </auto-generated>
#pragma warning disable 0414, 1591, 8981
#region Designer generated code

using grpc = global::Grpc.Core;

namespace GatewayProtocol {
  public static partial class Gateway
  {
    static readonly string __ServiceName = "gateway_protocol.Gateway";

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static void __Helper_SerializeMessage(global::Google.Protobuf.IMessage message, grpc::SerializationContext context)
    {
      #if !GRPC_DISABLE_PROTOBUF_BUFFER_SERIALIZATION
      if (message is global::Google.Protobuf.IBufferMessage)
      {
        context.SetPayloadLength(message.CalculateSize());
        global::Google.Protobuf.MessageExtensions.WriteTo(message, context.GetBufferWriter());
        context.Complete();
        return;
      }
      #endif
      context.Complete(global::Google.Protobuf.MessageExtensions.ToByteArray(message));
    }

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static class __Helper_MessageCache<T>
    {
      public static readonly bool IsBufferMessage = global::System.Reflection.IntrospectionExtensions.GetTypeInfo(typeof(global::Google.Protobuf.IBufferMessage)).IsAssignableFrom(typeof(T));
    }

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static T __Helper_DeserializeMessage<T>(grpc::DeserializationContext context, global::Google.Protobuf.MessageParser<T> parser) where T : global::Google.Protobuf.IMessage<T>
    {
      #if !GRPC_DISABLE_PROTOBUF_BUFFER_SERIALIZATION
      if (__Helper_MessageCache<T>.IsBufferMessage)
      {
        return parser.ParseFrom(context.PayloadAsReadOnlySequence());
      }
      #endif
      return parser.ParseFrom(context.PayloadAsNewBuffer());
    }

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::GatewayProtocol.ActivateJobsRequest> __Marshaller_gateway_protocol_ActivateJobsRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::GatewayProtocol.ActivateJobsRequest.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::GatewayProtocol.ActivateJobsResponse> __Marshaller_gateway_protocol_ActivateJobsResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::GatewayProtocol.ActivateJobsResponse.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::GatewayProtocol.CancelProcessInstanceRequest> __Marshaller_gateway_protocol_CancelProcessInstanceRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::GatewayProtocol.CancelProcessInstanceRequest.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::GatewayProtocol.CancelProcessInstanceResponse> __Marshaller_gateway_protocol_CancelProcessInstanceResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::GatewayProtocol.CancelProcessInstanceResponse.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::GatewayProtocol.CompleteJobRequest> __Marshaller_gateway_protocol_CompleteJobRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::GatewayProtocol.CompleteJobRequest.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::GatewayProtocol.CompleteJobResponse> __Marshaller_gateway_protocol_CompleteJobResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::GatewayProtocol.CompleteJobResponse.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::GatewayProtocol.CreateProcessInstanceRequest> __Marshaller_gateway_protocol_CreateProcessInstanceRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::GatewayProtocol.CreateProcessInstanceRequest.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::GatewayProtocol.CreateProcessInstanceResponse> __Marshaller_gateway_protocol_CreateProcessInstanceResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::GatewayProtocol.CreateProcessInstanceResponse.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::GatewayProtocol.CreateProcessInstanceWithResultRequest> __Marshaller_gateway_protocol_CreateProcessInstanceWithResultRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::GatewayProtocol.CreateProcessInstanceWithResultRequest.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::GatewayProtocol.CreateProcessInstanceWithResultResponse> __Marshaller_gateway_protocol_CreateProcessInstanceWithResultResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::GatewayProtocol.CreateProcessInstanceWithResultResponse.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::GatewayProtocol.DeployProcessRequest> __Marshaller_gateway_protocol_DeployProcessRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::GatewayProtocol.DeployProcessRequest.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::GatewayProtocol.DeployProcessResponse> __Marshaller_gateway_protocol_DeployProcessResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::GatewayProtocol.DeployProcessResponse.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::GatewayProtocol.DeployResourceRequest> __Marshaller_gateway_protocol_DeployResourceRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::GatewayProtocol.DeployResourceRequest.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::GatewayProtocol.DeployResourceResponse> __Marshaller_gateway_protocol_DeployResourceResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::GatewayProtocol.DeployResourceResponse.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::GatewayProtocol.FailJobRequest> __Marshaller_gateway_protocol_FailJobRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::GatewayProtocol.FailJobRequest.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::GatewayProtocol.FailJobResponse> __Marshaller_gateway_protocol_FailJobResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::GatewayProtocol.FailJobResponse.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::GatewayProtocol.ThrowErrorRequest> __Marshaller_gateway_protocol_ThrowErrorRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::GatewayProtocol.ThrowErrorRequest.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::GatewayProtocol.ThrowErrorResponse> __Marshaller_gateway_protocol_ThrowErrorResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::GatewayProtocol.ThrowErrorResponse.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::GatewayProtocol.PublishMessageRequest> __Marshaller_gateway_protocol_PublishMessageRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::GatewayProtocol.PublishMessageRequest.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::GatewayProtocol.PublishMessageResponse> __Marshaller_gateway_protocol_PublishMessageResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::GatewayProtocol.PublishMessageResponse.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::GatewayProtocol.ResolveIncidentRequest> __Marshaller_gateway_protocol_ResolveIncidentRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::GatewayProtocol.ResolveIncidentRequest.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::GatewayProtocol.ResolveIncidentResponse> __Marshaller_gateway_protocol_ResolveIncidentResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::GatewayProtocol.ResolveIncidentResponse.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::GatewayProtocol.SetVariablesRequest> __Marshaller_gateway_protocol_SetVariablesRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::GatewayProtocol.SetVariablesRequest.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::GatewayProtocol.SetVariablesResponse> __Marshaller_gateway_protocol_SetVariablesResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::GatewayProtocol.SetVariablesResponse.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::GatewayProtocol.TopologyRequest> __Marshaller_gateway_protocol_TopologyRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::GatewayProtocol.TopologyRequest.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::GatewayProtocol.TopologyResponse> __Marshaller_gateway_protocol_TopologyResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::GatewayProtocol.TopologyResponse.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::GatewayProtocol.UpdateJobRetriesRequest> __Marshaller_gateway_protocol_UpdateJobRetriesRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::GatewayProtocol.UpdateJobRetriesRequest.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::GatewayProtocol.UpdateJobRetriesResponse> __Marshaller_gateway_protocol_UpdateJobRetriesResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::GatewayProtocol.UpdateJobRetriesResponse.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::GatewayProtocol.ModifyProcessInstanceRequest> __Marshaller_gateway_protocol_ModifyProcessInstanceRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::GatewayProtocol.ModifyProcessInstanceRequest.Parser));
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Marshaller<global::GatewayProtocol.ModifyProcessInstanceResponse> __Marshaller_gateway_protocol_ModifyProcessInstanceResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::GatewayProtocol.ModifyProcessInstanceResponse.Parser));

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::GatewayProtocol.ActivateJobsRequest, global::GatewayProtocol.ActivateJobsResponse> __Method_ActivateJobs = new grpc::Method<global::GatewayProtocol.ActivateJobsRequest, global::GatewayProtocol.ActivateJobsResponse>(
        grpc::MethodType.ServerStreaming,
        __ServiceName,
        "ActivateJobs",
        __Marshaller_gateway_protocol_ActivateJobsRequest,
        __Marshaller_gateway_protocol_ActivateJobsResponse);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::GatewayProtocol.CancelProcessInstanceRequest, global::GatewayProtocol.CancelProcessInstanceResponse> __Method_CancelProcessInstance = new grpc::Method<global::GatewayProtocol.CancelProcessInstanceRequest, global::GatewayProtocol.CancelProcessInstanceResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "CancelProcessInstance",
        __Marshaller_gateway_protocol_CancelProcessInstanceRequest,
        __Marshaller_gateway_protocol_CancelProcessInstanceResponse);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::GatewayProtocol.CompleteJobRequest, global::GatewayProtocol.CompleteJobResponse> __Method_CompleteJob = new grpc::Method<global::GatewayProtocol.CompleteJobRequest, global::GatewayProtocol.CompleteJobResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "CompleteJob",
        __Marshaller_gateway_protocol_CompleteJobRequest,
        __Marshaller_gateway_protocol_CompleteJobResponse);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::GatewayProtocol.CreateProcessInstanceRequest, global::GatewayProtocol.CreateProcessInstanceResponse> __Method_CreateProcessInstance = new grpc::Method<global::GatewayProtocol.CreateProcessInstanceRequest, global::GatewayProtocol.CreateProcessInstanceResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "CreateProcessInstance",
        __Marshaller_gateway_protocol_CreateProcessInstanceRequest,
        __Marshaller_gateway_protocol_CreateProcessInstanceResponse);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::GatewayProtocol.CreateProcessInstanceWithResultRequest, global::GatewayProtocol.CreateProcessInstanceWithResultResponse> __Method_CreateProcessInstanceWithResult = new grpc::Method<global::GatewayProtocol.CreateProcessInstanceWithResultRequest, global::GatewayProtocol.CreateProcessInstanceWithResultResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "CreateProcessInstanceWithResult",
        __Marshaller_gateway_protocol_CreateProcessInstanceWithResultRequest,
        __Marshaller_gateway_protocol_CreateProcessInstanceWithResultResponse);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::GatewayProtocol.DeployProcessRequest, global::GatewayProtocol.DeployProcessResponse> __Method_DeployProcess = new grpc::Method<global::GatewayProtocol.DeployProcessRequest, global::GatewayProtocol.DeployProcessResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "DeployProcess",
        __Marshaller_gateway_protocol_DeployProcessRequest,
        __Marshaller_gateway_protocol_DeployProcessResponse);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::GatewayProtocol.DeployResourceRequest, global::GatewayProtocol.DeployResourceResponse> __Method_DeployResource = new grpc::Method<global::GatewayProtocol.DeployResourceRequest, global::GatewayProtocol.DeployResourceResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "DeployResource",
        __Marshaller_gateway_protocol_DeployResourceRequest,
        __Marshaller_gateway_protocol_DeployResourceResponse);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::GatewayProtocol.FailJobRequest, global::GatewayProtocol.FailJobResponse> __Method_FailJob = new grpc::Method<global::GatewayProtocol.FailJobRequest, global::GatewayProtocol.FailJobResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "FailJob",
        __Marshaller_gateway_protocol_FailJobRequest,
        __Marshaller_gateway_protocol_FailJobResponse);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::GatewayProtocol.ThrowErrorRequest, global::GatewayProtocol.ThrowErrorResponse> __Method_ThrowError = new grpc::Method<global::GatewayProtocol.ThrowErrorRequest, global::GatewayProtocol.ThrowErrorResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "ThrowError",
        __Marshaller_gateway_protocol_ThrowErrorRequest,
        __Marshaller_gateway_protocol_ThrowErrorResponse);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::GatewayProtocol.PublishMessageRequest, global::GatewayProtocol.PublishMessageResponse> __Method_PublishMessage = new grpc::Method<global::GatewayProtocol.PublishMessageRequest, global::GatewayProtocol.PublishMessageResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "PublishMessage",
        __Marshaller_gateway_protocol_PublishMessageRequest,
        __Marshaller_gateway_protocol_PublishMessageResponse);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::GatewayProtocol.ResolveIncidentRequest, global::GatewayProtocol.ResolveIncidentResponse> __Method_ResolveIncident = new grpc::Method<global::GatewayProtocol.ResolveIncidentRequest, global::GatewayProtocol.ResolveIncidentResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "ResolveIncident",
        __Marshaller_gateway_protocol_ResolveIncidentRequest,
        __Marshaller_gateway_protocol_ResolveIncidentResponse);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::GatewayProtocol.SetVariablesRequest, global::GatewayProtocol.SetVariablesResponse> __Method_SetVariables = new grpc::Method<global::GatewayProtocol.SetVariablesRequest, global::GatewayProtocol.SetVariablesResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "SetVariables",
        __Marshaller_gateway_protocol_SetVariablesRequest,
        __Marshaller_gateway_protocol_SetVariablesResponse);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::GatewayProtocol.TopologyRequest, global::GatewayProtocol.TopologyResponse> __Method_Topology = new grpc::Method<global::GatewayProtocol.TopologyRequest, global::GatewayProtocol.TopologyResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "Topology",
        __Marshaller_gateway_protocol_TopologyRequest,
        __Marshaller_gateway_protocol_TopologyResponse);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::GatewayProtocol.UpdateJobRetriesRequest, global::GatewayProtocol.UpdateJobRetriesResponse> __Method_UpdateJobRetries = new grpc::Method<global::GatewayProtocol.UpdateJobRetriesRequest, global::GatewayProtocol.UpdateJobRetriesResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "UpdateJobRetries",
        __Marshaller_gateway_protocol_UpdateJobRetriesRequest,
        __Marshaller_gateway_protocol_UpdateJobRetriesResponse);

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    static readonly grpc::Method<global::GatewayProtocol.ModifyProcessInstanceRequest, global::GatewayProtocol.ModifyProcessInstanceResponse> __Method_ModifyProcessInstance = new grpc::Method<global::GatewayProtocol.ModifyProcessInstanceRequest, global::GatewayProtocol.ModifyProcessInstanceResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "ModifyProcessInstance",
        __Marshaller_gateway_protocol_ModifyProcessInstanceRequest,
        __Marshaller_gateway_protocol_ModifyProcessInstanceResponse);

    /// <summary>Service descriptor</summary>
    public static global::Google.Protobuf.Reflection.ServiceDescriptor Descriptor
    {
      get { return global::GatewayProtocol.GatewayReflection.Descriptor.Services[0]; }
    }

    /// <summary>Base class for server-side implementations of Gateway</summary>
    [grpc::BindServiceMethod(typeof(Gateway), "BindService")]
    public abstract partial class GatewayBase
    {
      /// <summary>
      ///
      ///Iterates through all known partitions round-robin and activates up to the requested
      ///maximum and streams them back to the client as they are activated.
      ///
      ///Errors:
      ///INVALID_ARGUMENT:
      ///- type is blank (empty string, null)
      ///- worker is blank (empty string, null)
      ///- timeout less than 1
      ///- maxJobsToActivate is less than 1
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="responseStream">Used for sending responses back to the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>A task indicating completion of the handler.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task ActivateJobs(global::GatewayProtocol.ActivateJobsRequest request, grpc::IServerStreamWriter<global::GatewayProtocol.ActivateJobsResponse> responseStream, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///
      ///Cancels a running process instance
      ///
      ///Errors:
      ///NOT_FOUND:
      ///- no process instance exists with the given key
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::GatewayProtocol.CancelProcessInstanceResponse> CancelProcessInstance(global::GatewayProtocol.CancelProcessInstanceRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///
      ///Completes a job with the given variables, which allows completing the associated service task.
      ///
      ///Errors:
      ///NOT_FOUND:
      ///- no job exists with the given job key. Note that since jobs are removed once completed,
      ///it could be that this job did exist at some point.
      ///
      ///FAILED_PRECONDITION:
      ///- the job was marked as failed. In that case, the related incident must be resolved before
      ///the job can be activated again and completed.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::GatewayProtocol.CompleteJobResponse> CompleteJob(global::GatewayProtocol.CompleteJobRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///
      ///Creates and starts an instance of the specified process. The process definition to use to
      ///create the instance can be specified either using its unique key (as returned by
      ///DeployProcess), or using the BPMN process ID and a version. Pass -1 as the version to use the
      ///latest deployed version. Note that only processes with none start events can be started through
      ///this command.
      ///
      ///Errors:
      ///NOT_FOUND:
      ///- no process with the given key exists (if processDefinitionKey was given)
      ///- no process with the given process ID exists (if bpmnProcessId was given but version was -1)
      ///- no process with the given process ID and version exists (if both bpmnProcessId and version were given)
      ///
      ///FAILED_PRECONDITION:
      ///- the process definition does not contain a none start event; only processes with none
      ///start event can be started manually.
      ///
      ///INVALID_ARGUMENT:
      ///- the given variables argument is not a valid JSON document; it is expected to be a valid
      ///JSON document where the root node is an object.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::GatewayProtocol.CreateProcessInstanceResponse> CreateProcessInstance(global::GatewayProtocol.CreateProcessInstanceRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///
      ///Behaves similarly to `rpc CreateProcessInstance`, except that a successful response is received when the process completes successfully.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::GatewayProtocol.CreateProcessInstanceWithResultResponse> CreateProcessInstanceWithResult(global::GatewayProtocol.CreateProcessInstanceWithResultRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///
      ///Deploys one or more processes to Zeebe. Note that this is an atomic call,
      ///i.e. either all processes are deployed, or none of them are.
      ///
      ///Errors:
      ///INVALID_ARGUMENT:
      ///- no resources given.
      ///- if at least one resource is invalid. A resource is considered invalid if:
      ///- the resource data is not deserializable (e.g. detected as BPMN, but it's broken XML)
      ///- the process is invalid (e.g. an event-based gateway has an outgoing sequence flow to a task)
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::GatewayProtocol.DeployProcessResponse> DeployProcess(global::GatewayProtocol.DeployProcessRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///
      ///Deploys one or more resources (e.g. processes or decision models) to Zeebe.
      ///Note that this is an atomic call, i.e. either all resources are deployed, or none of them are.
      ///
      ///Errors:
      ///INVALID_ARGUMENT:
      ///- no resources given.
      ///- if at least one resource is invalid. A resource is considered invalid if:
      ///- the content is not deserializable (e.g. detected as BPMN, but it's broken XML)
      ///- the content is invalid (e.g. an event-based gateway has an outgoing sequence flow to a task)
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::GatewayProtocol.DeployResourceResponse> DeployResource(global::GatewayProtocol.DeployResourceRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///
      ///Marks the job as failed; if the retries argument is positive, then the job will be immediately
      ///activatable again, and a worker could try again to process it. If it is zero or negative however,
      ///an incident will be raised, tagged with the given errorMessage, and the job will not be
      ///activatable until the incident is resolved.
      ///
      ///Errors:
      ///NOT_FOUND:
      ///- no job was found with the given key
      ///
      ///FAILED_PRECONDITION:
      ///- the job was not activated
      ///- the job is already in a failed state, i.e. ran out of retries
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::GatewayProtocol.FailJobResponse> FailJob(global::GatewayProtocol.FailJobRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///
      ///Reports a business error (i.e. non-technical) that occurs while processing a job. The error is handled in the process by an error catch event. If there is no error catch event with the specified errorCode then an incident will be raised instead.
      ///
      ///Errors:
      ///NOT_FOUND:
      ///- no job was found with the given key
      ///
      ///FAILED_PRECONDITION:
      ///- the job is not in an activated state
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::GatewayProtocol.ThrowErrorResponse> ThrowError(global::GatewayProtocol.ThrowErrorRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///
      ///Publishes a single message. Messages are published to specific partitions computed from their
      ///correlation keys.
      ///
      ///Errors:
      ///ALREADY_EXISTS:
      ///- a message with the same ID was previously published (and is still alive)
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::GatewayProtocol.PublishMessageResponse> PublishMessage(global::GatewayProtocol.PublishMessageRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///
      ///Resolves a given incident. This simply marks the incident as resolved; most likely a call to
      ///UpdateJobRetries or SetVariables will be necessary to actually resolve the
      ///problem, following by this call.
      ///
      ///Errors:
      ///NOT_FOUND:
      ///- no incident with the given key exists
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::GatewayProtocol.ResolveIncidentResponse> ResolveIncident(global::GatewayProtocol.ResolveIncidentRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///
      ///Updates all the variables of a particular scope (e.g. process instance, flow element instance)
      ///from the given JSON document.
      ///
      ///Errors:
      ///NOT_FOUND:
      ///- no element with the given elementInstanceKey exists
      ///INVALID_ARGUMENT:
      ///- the given variables document is not a valid JSON document; valid documents are expected to
      ///be JSON documents where the root node is an object.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::GatewayProtocol.SetVariablesResponse> SetVariables(global::GatewayProtocol.SetVariablesRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///
      ///Obtains the current topology of the cluster the gateway is part of.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::GatewayProtocol.TopologyResponse> Topology(global::GatewayProtocol.TopologyRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///
      ///Updates the number of retries a job has left. This is mostly useful for jobs that have run out of
      ///retries, should the underlying problem be solved.
      ///
      ///Errors:
      ///NOT_FOUND:
      ///- no job exists with the given key
      ///
      ///INVALID_ARGUMENT:
      ///- retries is not greater than 0
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::GatewayProtocol.UpdateJobRetriesResponse> UpdateJobRetries(global::GatewayProtocol.UpdateJobRetriesRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///
      ///Modifies the process instance. This is done by activating and/or terminating specific elements of the instance.
      ///
      ///Errors:
      ///NOT_FOUND:
      ///- no process instance exists with the given key
      ///
      ///FAILED_PRECONDITION:
      ///- trying to activate element inside of a multi-instance
      ///
      ///INVALID_ARGUMENT:
      ///- activating or terminating unknown element
      ///- ancestor of element for activation doesn't exist
      ///- scope of variable is unknown
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::System.Threading.Tasks.Task<global::GatewayProtocol.ModifyProcessInstanceResponse> ModifyProcessInstance(global::GatewayProtocol.ModifyProcessInstanceRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

    }

    /// <summary>Client for Gateway</summary>
    public partial class GatewayClient : grpc::ClientBase<GatewayClient>
    {
      /// <summary>Creates a new client for Gateway</summary>
      /// <param name="channel">The channel to use to make remote calls.</param>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public GatewayClient(grpc::ChannelBase channel) : base(channel)
      {
      }
      /// <summary>Creates a new client for Gateway that uses a custom <c>CallInvoker</c>.</summary>
      /// <param name="callInvoker">The callInvoker to use to make remote calls.</param>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public GatewayClient(grpc::CallInvoker callInvoker) : base(callInvoker)
      {
      }
      /// <summary>Protected parameterless constructor to allow creation of test doubles.</summary>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      protected GatewayClient() : base()
      {
      }
      /// <summary>Protected constructor to allow creation of configured clients.</summary>
      /// <param name="configuration">The client configuration.</param>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      protected GatewayClient(ClientBaseConfiguration configuration) : base(configuration)
      {
      }

      /// <summary>
      ///
      ///Iterates through all known partitions round-robin and activates up to the requested
      ///maximum and streams them back to the client as they are activated.
      ///
      ///Errors:
      ///INVALID_ARGUMENT:
      ///- type is blank (empty string, null)
      ///- worker is blank (empty string, null)
      ///- timeout less than 1
      ///- maxJobsToActivate is less than 1
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncServerStreamingCall<global::GatewayProtocol.ActivateJobsResponse> ActivateJobs(global::GatewayProtocol.ActivateJobsRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return ActivateJobs(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///
      ///Iterates through all known partitions round-robin and activates up to the requested
      ///maximum and streams them back to the client as they are activated.
      ///
      ///Errors:
      ///INVALID_ARGUMENT:
      ///- type is blank (empty string, null)
      ///- worker is blank (empty string, null)
      ///- timeout less than 1
      ///- maxJobsToActivate is less than 1
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncServerStreamingCall<global::GatewayProtocol.ActivateJobsResponse> ActivateJobs(global::GatewayProtocol.ActivateJobsRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncServerStreamingCall(__Method_ActivateJobs, null, options, request);
      }
      /// <summary>
      ///
      ///Cancels a running process instance
      ///
      ///Errors:
      ///NOT_FOUND:
      ///- no process instance exists with the given key
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::GatewayProtocol.CancelProcessInstanceResponse CancelProcessInstance(global::GatewayProtocol.CancelProcessInstanceRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return CancelProcessInstance(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///
      ///Cancels a running process instance
      ///
      ///Errors:
      ///NOT_FOUND:
      ///- no process instance exists with the given key
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::GatewayProtocol.CancelProcessInstanceResponse CancelProcessInstance(global::GatewayProtocol.CancelProcessInstanceRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_CancelProcessInstance, null, options, request);
      }
      /// <summary>
      ///
      ///Cancels a running process instance
      ///
      ///Errors:
      ///NOT_FOUND:
      ///- no process instance exists with the given key
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::GatewayProtocol.CancelProcessInstanceResponse> CancelProcessInstanceAsync(global::GatewayProtocol.CancelProcessInstanceRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return CancelProcessInstanceAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///
      ///Cancels a running process instance
      ///
      ///Errors:
      ///NOT_FOUND:
      ///- no process instance exists with the given key
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::GatewayProtocol.CancelProcessInstanceResponse> CancelProcessInstanceAsync(global::GatewayProtocol.CancelProcessInstanceRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_CancelProcessInstance, null, options, request);
      }
      /// <summary>
      ///
      ///Completes a job with the given variables, which allows completing the associated service task.
      ///
      ///Errors:
      ///NOT_FOUND:
      ///- no job exists with the given job key. Note that since jobs are removed once completed,
      ///it could be that this job did exist at some point.
      ///
      ///FAILED_PRECONDITION:
      ///- the job was marked as failed. In that case, the related incident must be resolved before
      ///the job can be activated again and completed.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::GatewayProtocol.CompleteJobResponse CompleteJob(global::GatewayProtocol.CompleteJobRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return CompleteJob(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///
      ///Completes a job with the given variables, which allows completing the associated service task.
      ///
      ///Errors:
      ///NOT_FOUND:
      ///- no job exists with the given job key. Note that since jobs are removed once completed,
      ///it could be that this job did exist at some point.
      ///
      ///FAILED_PRECONDITION:
      ///- the job was marked as failed. In that case, the related incident must be resolved before
      ///the job can be activated again and completed.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::GatewayProtocol.CompleteJobResponse CompleteJob(global::GatewayProtocol.CompleteJobRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_CompleteJob, null, options, request);
      }
      /// <summary>
      ///
      ///Completes a job with the given variables, which allows completing the associated service task.
      ///
      ///Errors:
      ///NOT_FOUND:
      ///- no job exists with the given job key. Note that since jobs are removed once completed,
      ///it could be that this job did exist at some point.
      ///
      ///FAILED_PRECONDITION:
      ///- the job was marked as failed. In that case, the related incident must be resolved before
      ///the job can be activated again and completed.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::GatewayProtocol.CompleteJobResponse> CompleteJobAsync(global::GatewayProtocol.CompleteJobRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return CompleteJobAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///
      ///Completes a job with the given variables, which allows completing the associated service task.
      ///
      ///Errors:
      ///NOT_FOUND:
      ///- no job exists with the given job key. Note that since jobs are removed once completed,
      ///it could be that this job did exist at some point.
      ///
      ///FAILED_PRECONDITION:
      ///- the job was marked as failed. In that case, the related incident must be resolved before
      ///the job can be activated again and completed.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::GatewayProtocol.CompleteJobResponse> CompleteJobAsync(global::GatewayProtocol.CompleteJobRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_CompleteJob, null, options, request);
      }
      /// <summary>
      ///
      ///Creates and starts an instance of the specified process. The process definition to use to
      ///create the instance can be specified either using its unique key (as returned by
      ///DeployProcess), or using the BPMN process ID and a version. Pass -1 as the version to use the
      ///latest deployed version. Note that only processes with none start events can be started through
      ///this command.
      ///
      ///Errors:
      ///NOT_FOUND:
      ///- no process with the given key exists (if processDefinitionKey was given)
      ///- no process with the given process ID exists (if bpmnProcessId was given but version was -1)
      ///- no process with the given process ID and version exists (if both bpmnProcessId and version were given)
      ///
      ///FAILED_PRECONDITION:
      ///- the process definition does not contain a none start event; only processes with none
      ///start event can be started manually.
      ///
      ///INVALID_ARGUMENT:
      ///- the given variables argument is not a valid JSON document; it is expected to be a valid
      ///JSON document where the root node is an object.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::GatewayProtocol.CreateProcessInstanceResponse CreateProcessInstance(global::GatewayProtocol.CreateProcessInstanceRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return CreateProcessInstance(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///
      ///Creates and starts an instance of the specified process. The process definition to use to
      ///create the instance can be specified either using its unique key (as returned by
      ///DeployProcess), or using the BPMN process ID and a version. Pass -1 as the version to use the
      ///latest deployed version. Note that only processes with none start events can be started through
      ///this command.
      ///
      ///Errors:
      ///NOT_FOUND:
      ///- no process with the given key exists (if processDefinitionKey was given)
      ///- no process with the given process ID exists (if bpmnProcessId was given but version was -1)
      ///- no process with the given process ID and version exists (if both bpmnProcessId and version were given)
      ///
      ///FAILED_PRECONDITION:
      ///- the process definition does not contain a none start event; only processes with none
      ///start event can be started manually.
      ///
      ///INVALID_ARGUMENT:
      ///- the given variables argument is not a valid JSON document; it is expected to be a valid
      ///JSON document where the root node is an object.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::GatewayProtocol.CreateProcessInstanceResponse CreateProcessInstance(global::GatewayProtocol.CreateProcessInstanceRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_CreateProcessInstance, null, options, request);
      }
      /// <summary>
      ///
      ///Creates and starts an instance of the specified process. The process definition to use to
      ///create the instance can be specified either using its unique key (as returned by
      ///DeployProcess), or using the BPMN process ID and a version. Pass -1 as the version to use the
      ///latest deployed version. Note that only processes with none start events can be started through
      ///this command.
      ///
      ///Errors:
      ///NOT_FOUND:
      ///- no process with the given key exists (if processDefinitionKey was given)
      ///- no process with the given process ID exists (if bpmnProcessId was given but version was -1)
      ///- no process with the given process ID and version exists (if both bpmnProcessId and version were given)
      ///
      ///FAILED_PRECONDITION:
      ///- the process definition does not contain a none start event; only processes with none
      ///start event can be started manually.
      ///
      ///INVALID_ARGUMENT:
      ///- the given variables argument is not a valid JSON document; it is expected to be a valid
      ///JSON document where the root node is an object.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::GatewayProtocol.CreateProcessInstanceResponse> CreateProcessInstanceAsync(global::GatewayProtocol.CreateProcessInstanceRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return CreateProcessInstanceAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///
      ///Creates and starts an instance of the specified process. The process definition to use to
      ///create the instance can be specified either using its unique key (as returned by
      ///DeployProcess), or using the BPMN process ID and a version. Pass -1 as the version to use the
      ///latest deployed version. Note that only processes with none start events can be started through
      ///this command.
      ///
      ///Errors:
      ///NOT_FOUND:
      ///- no process with the given key exists (if processDefinitionKey was given)
      ///- no process with the given process ID exists (if bpmnProcessId was given but version was -1)
      ///- no process with the given process ID and version exists (if both bpmnProcessId and version were given)
      ///
      ///FAILED_PRECONDITION:
      ///- the process definition does not contain a none start event; only processes with none
      ///start event can be started manually.
      ///
      ///INVALID_ARGUMENT:
      ///- the given variables argument is not a valid JSON document; it is expected to be a valid
      ///JSON document where the root node is an object.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::GatewayProtocol.CreateProcessInstanceResponse> CreateProcessInstanceAsync(global::GatewayProtocol.CreateProcessInstanceRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_CreateProcessInstance, null, options, request);
      }
      /// <summary>
      ///
      ///Behaves similarly to `rpc CreateProcessInstance`, except that a successful response is received when the process completes successfully.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::GatewayProtocol.CreateProcessInstanceWithResultResponse CreateProcessInstanceWithResult(global::GatewayProtocol.CreateProcessInstanceWithResultRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return CreateProcessInstanceWithResult(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///
      ///Behaves similarly to `rpc CreateProcessInstance`, except that a successful response is received when the process completes successfully.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::GatewayProtocol.CreateProcessInstanceWithResultResponse CreateProcessInstanceWithResult(global::GatewayProtocol.CreateProcessInstanceWithResultRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_CreateProcessInstanceWithResult, null, options, request);
      }
      /// <summary>
      ///
      ///Behaves similarly to `rpc CreateProcessInstance`, except that a successful response is received when the process completes successfully.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::GatewayProtocol.CreateProcessInstanceWithResultResponse> CreateProcessInstanceWithResultAsync(global::GatewayProtocol.CreateProcessInstanceWithResultRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return CreateProcessInstanceWithResultAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///
      ///Behaves similarly to `rpc CreateProcessInstance`, except that a successful response is received when the process completes successfully.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::GatewayProtocol.CreateProcessInstanceWithResultResponse> CreateProcessInstanceWithResultAsync(global::GatewayProtocol.CreateProcessInstanceWithResultRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_CreateProcessInstanceWithResult, null, options, request);
      }
      /// <summary>
      ///
      ///Deploys one or more processes to Zeebe. Note that this is an atomic call,
      ///i.e. either all processes are deployed, or none of them are.
      ///
      ///Errors:
      ///INVALID_ARGUMENT:
      ///- no resources given.
      ///- if at least one resource is invalid. A resource is considered invalid if:
      ///- the resource data is not deserializable (e.g. detected as BPMN, but it's broken XML)
      ///- the process is invalid (e.g. an event-based gateway has an outgoing sequence flow to a task)
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::GatewayProtocol.DeployProcessResponse DeployProcess(global::GatewayProtocol.DeployProcessRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return DeployProcess(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///
      ///Deploys one or more processes to Zeebe. Note that this is an atomic call,
      ///i.e. either all processes are deployed, or none of them are.
      ///
      ///Errors:
      ///INVALID_ARGUMENT:
      ///- no resources given.
      ///- if at least one resource is invalid. A resource is considered invalid if:
      ///- the resource data is not deserializable (e.g. detected as BPMN, but it's broken XML)
      ///- the process is invalid (e.g. an event-based gateway has an outgoing sequence flow to a task)
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::GatewayProtocol.DeployProcessResponse DeployProcess(global::GatewayProtocol.DeployProcessRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_DeployProcess, null, options, request);
      }
      /// <summary>
      ///
      ///Deploys one or more processes to Zeebe. Note that this is an atomic call,
      ///i.e. either all processes are deployed, or none of them are.
      ///
      ///Errors:
      ///INVALID_ARGUMENT:
      ///- no resources given.
      ///- if at least one resource is invalid. A resource is considered invalid if:
      ///- the resource data is not deserializable (e.g. detected as BPMN, but it's broken XML)
      ///- the process is invalid (e.g. an event-based gateway has an outgoing sequence flow to a task)
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::GatewayProtocol.DeployProcessResponse> DeployProcessAsync(global::GatewayProtocol.DeployProcessRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return DeployProcessAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///
      ///Deploys one or more processes to Zeebe. Note that this is an atomic call,
      ///i.e. either all processes are deployed, or none of them are.
      ///
      ///Errors:
      ///INVALID_ARGUMENT:
      ///- no resources given.
      ///- if at least one resource is invalid. A resource is considered invalid if:
      ///- the resource data is not deserializable (e.g. detected as BPMN, but it's broken XML)
      ///- the process is invalid (e.g. an event-based gateway has an outgoing sequence flow to a task)
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::GatewayProtocol.DeployProcessResponse> DeployProcessAsync(global::GatewayProtocol.DeployProcessRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_DeployProcess, null, options, request);
      }
      /// <summary>
      ///
      ///Deploys one or more resources (e.g. processes or decision models) to Zeebe.
      ///Note that this is an atomic call, i.e. either all resources are deployed, or none of them are.
      ///
      ///Errors:
      ///INVALID_ARGUMENT:
      ///- no resources given.
      ///- if at least one resource is invalid. A resource is considered invalid if:
      ///- the content is not deserializable (e.g. detected as BPMN, but it's broken XML)
      ///- the content is invalid (e.g. an event-based gateway has an outgoing sequence flow to a task)
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::GatewayProtocol.DeployResourceResponse DeployResource(global::GatewayProtocol.DeployResourceRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return DeployResource(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///
      ///Deploys one or more resources (e.g. processes or decision models) to Zeebe.
      ///Note that this is an atomic call, i.e. either all resources are deployed, or none of them are.
      ///
      ///Errors:
      ///INVALID_ARGUMENT:
      ///- no resources given.
      ///- if at least one resource is invalid. A resource is considered invalid if:
      ///- the content is not deserializable (e.g. detected as BPMN, but it's broken XML)
      ///- the content is invalid (e.g. an event-based gateway has an outgoing sequence flow to a task)
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::GatewayProtocol.DeployResourceResponse DeployResource(global::GatewayProtocol.DeployResourceRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_DeployResource, null, options, request);
      }
      /// <summary>
      ///
      ///Deploys one or more resources (e.g. processes or decision models) to Zeebe.
      ///Note that this is an atomic call, i.e. either all resources are deployed, or none of them are.
      ///
      ///Errors:
      ///INVALID_ARGUMENT:
      ///- no resources given.
      ///- if at least one resource is invalid. A resource is considered invalid if:
      ///- the content is not deserializable (e.g. detected as BPMN, but it's broken XML)
      ///- the content is invalid (e.g. an event-based gateway has an outgoing sequence flow to a task)
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::GatewayProtocol.DeployResourceResponse> DeployResourceAsync(global::GatewayProtocol.DeployResourceRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return DeployResourceAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///
      ///Deploys one or more resources (e.g. processes or decision models) to Zeebe.
      ///Note that this is an atomic call, i.e. either all resources are deployed, or none of them are.
      ///
      ///Errors:
      ///INVALID_ARGUMENT:
      ///- no resources given.
      ///- if at least one resource is invalid. A resource is considered invalid if:
      ///- the content is not deserializable (e.g. detected as BPMN, but it's broken XML)
      ///- the content is invalid (e.g. an event-based gateway has an outgoing sequence flow to a task)
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::GatewayProtocol.DeployResourceResponse> DeployResourceAsync(global::GatewayProtocol.DeployResourceRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_DeployResource, null, options, request);
      }
      /// <summary>
      ///
      ///Marks the job as failed; if the retries argument is positive, then the job will be immediately
      ///activatable again, and a worker could try again to process it. If it is zero or negative however,
      ///an incident will be raised, tagged with the given errorMessage, and the job will not be
      ///activatable until the incident is resolved.
      ///
      ///Errors:
      ///NOT_FOUND:
      ///- no job was found with the given key
      ///
      ///FAILED_PRECONDITION:
      ///- the job was not activated
      ///- the job is already in a failed state, i.e. ran out of retries
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::GatewayProtocol.FailJobResponse FailJob(global::GatewayProtocol.FailJobRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return FailJob(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///
      ///Marks the job as failed; if the retries argument is positive, then the job will be immediately
      ///activatable again, and a worker could try again to process it. If it is zero or negative however,
      ///an incident will be raised, tagged with the given errorMessage, and the job will not be
      ///activatable until the incident is resolved.
      ///
      ///Errors:
      ///NOT_FOUND:
      ///- no job was found with the given key
      ///
      ///FAILED_PRECONDITION:
      ///- the job was not activated
      ///- the job is already in a failed state, i.e. ran out of retries
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::GatewayProtocol.FailJobResponse FailJob(global::GatewayProtocol.FailJobRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_FailJob, null, options, request);
      }
      /// <summary>
      ///
      ///Marks the job as failed; if the retries argument is positive, then the job will be immediately
      ///activatable again, and a worker could try again to process it. If it is zero or negative however,
      ///an incident will be raised, tagged with the given errorMessage, and the job will not be
      ///activatable until the incident is resolved.
      ///
      ///Errors:
      ///NOT_FOUND:
      ///- no job was found with the given key
      ///
      ///FAILED_PRECONDITION:
      ///- the job was not activated
      ///- the job is already in a failed state, i.e. ran out of retries
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::GatewayProtocol.FailJobResponse> FailJobAsync(global::GatewayProtocol.FailJobRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return FailJobAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///
      ///Marks the job as failed; if the retries argument is positive, then the job will be immediately
      ///activatable again, and a worker could try again to process it. If it is zero or negative however,
      ///an incident will be raised, tagged with the given errorMessage, and the job will not be
      ///activatable until the incident is resolved.
      ///
      ///Errors:
      ///NOT_FOUND:
      ///- no job was found with the given key
      ///
      ///FAILED_PRECONDITION:
      ///- the job was not activated
      ///- the job is already in a failed state, i.e. ran out of retries
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::GatewayProtocol.FailJobResponse> FailJobAsync(global::GatewayProtocol.FailJobRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_FailJob, null, options, request);
      }
      /// <summary>
      ///
      ///Reports a business error (i.e. non-technical) that occurs while processing a job. The error is handled in the process by an error catch event. If there is no error catch event with the specified errorCode then an incident will be raised instead.
      ///
      ///Errors:
      ///NOT_FOUND:
      ///- no job was found with the given key
      ///
      ///FAILED_PRECONDITION:
      ///- the job is not in an activated state
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::GatewayProtocol.ThrowErrorResponse ThrowError(global::GatewayProtocol.ThrowErrorRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return ThrowError(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///
      ///Reports a business error (i.e. non-technical) that occurs while processing a job. The error is handled in the process by an error catch event. If there is no error catch event with the specified errorCode then an incident will be raised instead.
      ///
      ///Errors:
      ///NOT_FOUND:
      ///- no job was found with the given key
      ///
      ///FAILED_PRECONDITION:
      ///- the job is not in an activated state
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::GatewayProtocol.ThrowErrorResponse ThrowError(global::GatewayProtocol.ThrowErrorRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_ThrowError, null, options, request);
      }
      /// <summary>
      ///
      ///Reports a business error (i.e. non-technical) that occurs while processing a job. The error is handled in the process by an error catch event. If there is no error catch event with the specified errorCode then an incident will be raised instead.
      ///
      ///Errors:
      ///NOT_FOUND:
      ///- no job was found with the given key
      ///
      ///FAILED_PRECONDITION:
      ///- the job is not in an activated state
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::GatewayProtocol.ThrowErrorResponse> ThrowErrorAsync(global::GatewayProtocol.ThrowErrorRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return ThrowErrorAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///
      ///Reports a business error (i.e. non-technical) that occurs while processing a job. The error is handled in the process by an error catch event. If there is no error catch event with the specified errorCode then an incident will be raised instead.
      ///
      ///Errors:
      ///NOT_FOUND:
      ///- no job was found with the given key
      ///
      ///FAILED_PRECONDITION:
      ///- the job is not in an activated state
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::GatewayProtocol.ThrowErrorResponse> ThrowErrorAsync(global::GatewayProtocol.ThrowErrorRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_ThrowError, null, options, request);
      }
      /// <summary>
      ///
      ///Publishes a single message. Messages are published to specific partitions computed from their
      ///correlation keys.
      ///
      ///Errors:
      ///ALREADY_EXISTS:
      ///- a message with the same ID was previously published (and is still alive)
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::GatewayProtocol.PublishMessageResponse PublishMessage(global::GatewayProtocol.PublishMessageRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return PublishMessage(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///
      ///Publishes a single message. Messages are published to specific partitions computed from their
      ///correlation keys.
      ///
      ///Errors:
      ///ALREADY_EXISTS:
      ///- a message with the same ID was previously published (and is still alive)
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::GatewayProtocol.PublishMessageResponse PublishMessage(global::GatewayProtocol.PublishMessageRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_PublishMessage, null, options, request);
      }
      /// <summary>
      ///
      ///Publishes a single message. Messages are published to specific partitions computed from their
      ///correlation keys.
      ///
      ///Errors:
      ///ALREADY_EXISTS:
      ///- a message with the same ID was previously published (and is still alive)
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::GatewayProtocol.PublishMessageResponse> PublishMessageAsync(global::GatewayProtocol.PublishMessageRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return PublishMessageAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///
      ///Publishes a single message. Messages are published to specific partitions computed from their
      ///correlation keys.
      ///
      ///Errors:
      ///ALREADY_EXISTS:
      ///- a message with the same ID was previously published (and is still alive)
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::GatewayProtocol.PublishMessageResponse> PublishMessageAsync(global::GatewayProtocol.PublishMessageRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_PublishMessage, null, options, request);
      }
      /// <summary>
      ///
      ///Resolves a given incident. This simply marks the incident as resolved; most likely a call to
      ///UpdateJobRetries or SetVariables will be necessary to actually resolve the
      ///problem, following by this call.
      ///
      ///Errors:
      ///NOT_FOUND:
      ///- no incident with the given key exists
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::GatewayProtocol.ResolveIncidentResponse ResolveIncident(global::GatewayProtocol.ResolveIncidentRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return ResolveIncident(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///
      ///Resolves a given incident. This simply marks the incident as resolved; most likely a call to
      ///UpdateJobRetries or SetVariables will be necessary to actually resolve the
      ///problem, following by this call.
      ///
      ///Errors:
      ///NOT_FOUND:
      ///- no incident with the given key exists
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::GatewayProtocol.ResolveIncidentResponse ResolveIncident(global::GatewayProtocol.ResolveIncidentRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_ResolveIncident, null, options, request);
      }
      /// <summary>
      ///
      ///Resolves a given incident. This simply marks the incident as resolved; most likely a call to
      ///UpdateJobRetries or SetVariables will be necessary to actually resolve the
      ///problem, following by this call.
      ///
      ///Errors:
      ///NOT_FOUND:
      ///- no incident with the given key exists
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::GatewayProtocol.ResolveIncidentResponse> ResolveIncidentAsync(global::GatewayProtocol.ResolveIncidentRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return ResolveIncidentAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///
      ///Resolves a given incident. This simply marks the incident as resolved; most likely a call to
      ///UpdateJobRetries or SetVariables will be necessary to actually resolve the
      ///problem, following by this call.
      ///
      ///Errors:
      ///NOT_FOUND:
      ///- no incident with the given key exists
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::GatewayProtocol.ResolveIncidentResponse> ResolveIncidentAsync(global::GatewayProtocol.ResolveIncidentRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_ResolveIncident, null, options, request);
      }
      /// <summary>
      ///
      ///Updates all the variables of a particular scope (e.g. process instance, flow element instance)
      ///from the given JSON document.
      ///
      ///Errors:
      ///NOT_FOUND:
      ///- no element with the given elementInstanceKey exists
      ///INVALID_ARGUMENT:
      ///- the given variables document is not a valid JSON document; valid documents are expected to
      ///be JSON documents where the root node is an object.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::GatewayProtocol.SetVariablesResponse SetVariables(global::GatewayProtocol.SetVariablesRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SetVariables(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///
      ///Updates all the variables of a particular scope (e.g. process instance, flow element instance)
      ///from the given JSON document.
      ///
      ///Errors:
      ///NOT_FOUND:
      ///- no element with the given elementInstanceKey exists
      ///INVALID_ARGUMENT:
      ///- the given variables document is not a valid JSON document; valid documents are expected to
      ///be JSON documents where the root node is an object.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::GatewayProtocol.SetVariablesResponse SetVariables(global::GatewayProtocol.SetVariablesRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_SetVariables, null, options, request);
      }
      /// <summary>
      ///
      ///Updates all the variables of a particular scope (e.g. process instance, flow element instance)
      ///from the given JSON document.
      ///
      ///Errors:
      ///NOT_FOUND:
      ///- no element with the given elementInstanceKey exists
      ///INVALID_ARGUMENT:
      ///- the given variables document is not a valid JSON document; valid documents are expected to
      ///be JSON documents where the root node is an object.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::GatewayProtocol.SetVariablesResponse> SetVariablesAsync(global::GatewayProtocol.SetVariablesRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SetVariablesAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///
      ///Updates all the variables of a particular scope (e.g. process instance, flow element instance)
      ///from the given JSON document.
      ///
      ///Errors:
      ///NOT_FOUND:
      ///- no element with the given elementInstanceKey exists
      ///INVALID_ARGUMENT:
      ///- the given variables document is not a valid JSON document; valid documents are expected to
      ///be JSON documents where the root node is an object.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::GatewayProtocol.SetVariablesResponse> SetVariablesAsync(global::GatewayProtocol.SetVariablesRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_SetVariables, null, options, request);
      }
      /// <summary>
      ///
      ///Obtains the current topology of the cluster the gateway is part of.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::GatewayProtocol.TopologyResponse Topology(global::GatewayProtocol.TopologyRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return Topology(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///
      ///Obtains the current topology of the cluster the gateway is part of.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::GatewayProtocol.TopologyResponse Topology(global::GatewayProtocol.TopologyRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_Topology, null, options, request);
      }
      /// <summary>
      ///
      ///Obtains the current topology of the cluster the gateway is part of.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::GatewayProtocol.TopologyResponse> TopologyAsync(global::GatewayProtocol.TopologyRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return TopologyAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///
      ///Obtains the current topology of the cluster the gateway is part of.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::GatewayProtocol.TopologyResponse> TopologyAsync(global::GatewayProtocol.TopologyRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_Topology, null, options, request);
      }
      /// <summary>
      ///
      ///Updates the number of retries a job has left. This is mostly useful for jobs that have run out of
      ///retries, should the underlying problem be solved.
      ///
      ///Errors:
      ///NOT_FOUND:
      ///- no job exists with the given key
      ///
      ///INVALID_ARGUMENT:
      ///- retries is not greater than 0
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::GatewayProtocol.UpdateJobRetriesResponse UpdateJobRetries(global::GatewayProtocol.UpdateJobRetriesRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return UpdateJobRetries(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///
      ///Updates the number of retries a job has left. This is mostly useful for jobs that have run out of
      ///retries, should the underlying problem be solved.
      ///
      ///Errors:
      ///NOT_FOUND:
      ///- no job exists with the given key
      ///
      ///INVALID_ARGUMENT:
      ///- retries is not greater than 0
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::GatewayProtocol.UpdateJobRetriesResponse UpdateJobRetries(global::GatewayProtocol.UpdateJobRetriesRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_UpdateJobRetries, null, options, request);
      }
      /// <summary>
      ///
      ///Updates the number of retries a job has left. This is mostly useful for jobs that have run out of
      ///retries, should the underlying problem be solved.
      ///
      ///Errors:
      ///NOT_FOUND:
      ///- no job exists with the given key
      ///
      ///INVALID_ARGUMENT:
      ///- retries is not greater than 0
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::GatewayProtocol.UpdateJobRetriesResponse> UpdateJobRetriesAsync(global::GatewayProtocol.UpdateJobRetriesRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return UpdateJobRetriesAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///
      ///Updates the number of retries a job has left. This is mostly useful for jobs that have run out of
      ///retries, should the underlying problem be solved.
      ///
      ///Errors:
      ///NOT_FOUND:
      ///- no job exists with the given key
      ///
      ///INVALID_ARGUMENT:
      ///- retries is not greater than 0
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::GatewayProtocol.UpdateJobRetriesResponse> UpdateJobRetriesAsync(global::GatewayProtocol.UpdateJobRetriesRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_UpdateJobRetries, null, options, request);
      }
      /// <summary>
      ///
      ///Modifies the process instance. This is done by activating and/or terminating specific elements of the instance.
      ///
      ///Errors:
      ///NOT_FOUND:
      ///- no process instance exists with the given key
      ///
      ///FAILED_PRECONDITION:
      ///- trying to activate element inside of a multi-instance
      ///
      ///INVALID_ARGUMENT:
      ///- activating or terminating unknown element
      ///- ancestor of element for activation doesn't exist
      ///- scope of variable is unknown
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::GatewayProtocol.ModifyProcessInstanceResponse ModifyProcessInstance(global::GatewayProtocol.ModifyProcessInstanceRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return ModifyProcessInstance(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///
      ///Modifies the process instance. This is done by activating and/or terminating specific elements of the instance.
      ///
      ///Errors:
      ///NOT_FOUND:
      ///- no process instance exists with the given key
      ///
      ///FAILED_PRECONDITION:
      ///- trying to activate element inside of a multi-instance
      ///
      ///INVALID_ARGUMENT:
      ///- activating or terminating unknown element
      ///- ancestor of element for activation doesn't exist
      ///- scope of variable is unknown
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual global::GatewayProtocol.ModifyProcessInstanceResponse ModifyProcessInstance(global::GatewayProtocol.ModifyProcessInstanceRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_ModifyProcessInstance, null, options, request);
      }
      /// <summary>
      ///
      ///Modifies the process instance. This is done by activating and/or terminating specific elements of the instance.
      ///
      ///Errors:
      ///NOT_FOUND:
      ///- no process instance exists with the given key
      ///
      ///FAILED_PRECONDITION:
      ///- trying to activate element inside of a multi-instance
      ///
      ///INVALID_ARGUMENT:
      ///- activating or terminating unknown element
      ///- ancestor of element for activation doesn't exist
      ///- scope of variable is unknown
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::GatewayProtocol.ModifyProcessInstanceResponse> ModifyProcessInstanceAsync(global::GatewayProtocol.ModifyProcessInstanceRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return ModifyProcessInstanceAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///
      ///Modifies the process instance. This is done by activating and/or terminating specific elements of the instance.
      ///
      ///Errors:
      ///NOT_FOUND:
      ///- no process instance exists with the given key
      ///
      ///FAILED_PRECONDITION:
      ///- trying to activate element inside of a multi-instance
      ///
      ///INVALID_ARGUMENT:
      ///- activating or terminating unknown element
      ///- ancestor of element for activation doesn't exist
      ///- scope of variable is unknown
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      public virtual grpc::AsyncUnaryCall<global::GatewayProtocol.ModifyProcessInstanceResponse> ModifyProcessInstanceAsync(global::GatewayProtocol.ModifyProcessInstanceRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_ModifyProcessInstance, null, options, request);
      }
      /// <summary>Creates a new instance of client from given <c>ClientBaseConfiguration</c>.</summary>
      [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
      protected override GatewayClient NewInstance(ClientBaseConfiguration configuration)
      {
        return new GatewayClient(configuration);
      }
    }

    /// <summary>Creates service definition that can be registered with a server</summary>
    /// <param name="serviceImpl">An object implementing the server-side handling logic.</param>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public static grpc::ServerServiceDefinition BindService(GatewayBase serviceImpl)
    {
      return grpc::ServerServiceDefinition.CreateBuilder()
          .AddMethod(__Method_ActivateJobs, serviceImpl.ActivateJobs)
          .AddMethod(__Method_CancelProcessInstance, serviceImpl.CancelProcessInstance)
          .AddMethod(__Method_CompleteJob, serviceImpl.CompleteJob)
          .AddMethod(__Method_CreateProcessInstance, serviceImpl.CreateProcessInstance)
          .AddMethod(__Method_CreateProcessInstanceWithResult, serviceImpl.CreateProcessInstanceWithResult)
          .AddMethod(__Method_DeployProcess, serviceImpl.DeployProcess)
          .AddMethod(__Method_DeployResource, serviceImpl.DeployResource)
          .AddMethod(__Method_FailJob, serviceImpl.FailJob)
          .AddMethod(__Method_ThrowError, serviceImpl.ThrowError)
          .AddMethod(__Method_PublishMessage, serviceImpl.PublishMessage)
          .AddMethod(__Method_ResolveIncident, serviceImpl.ResolveIncident)
          .AddMethod(__Method_SetVariables, serviceImpl.SetVariables)
          .AddMethod(__Method_Topology, serviceImpl.Topology)
          .AddMethod(__Method_UpdateJobRetries, serviceImpl.UpdateJobRetries)
          .AddMethod(__Method_ModifyProcessInstance, serviceImpl.ModifyProcessInstance).Build();
    }

    /// <summary>Register service method with a service binder with or without implementation. Useful when customizing the service binding logic.
    /// Note: this method is part of an experimental API that can change or be removed without any prior notice.</summary>
    /// <param name="serviceBinder">Service methods will be bound by calling <c>AddMethod</c> on this object.</param>
    /// <param name="serviceImpl">An object implementing the server-side handling logic.</param>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public static void BindService(grpc::ServiceBinderBase serviceBinder, GatewayBase serviceImpl)
    {
      serviceBinder.AddMethod(__Method_ActivateJobs, serviceImpl == null ? null : new grpc::ServerStreamingServerMethod<global::GatewayProtocol.ActivateJobsRequest, global::GatewayProtocol.ActivateJobsResponse>(serviceImpl.ActivateJobs));
      serviceBinder.AddMethod(__Method_CancelProcessInstance, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::GatewayProtocol.CancelProcessInstanceRequest, global::GatewayProtocol.CancelProcessInstanceResponse>(serviceImpl.CancelProcessInstance));
      serviceBinder.AddMethod(__Method_CompleteJob, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::GatewayProtocol.CompleteJobRequest, global::GatewayProtocol.CompleteJobResponse>(serviceImpl.CompleteJob));
      serviceBinder.AddMethod(__Method_CreateProcessInstance, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::GatewayProtocol.CreateProcessInstanceRequest, global::GatewayProtocol.CreateProcessInstanceResponse>(serviceImpl.CreateProcessInstance));
      serviceBinder.AddMethod(__Method_CreateProcessInstanceWithResult, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::GatewayProtocol.CreateProcessInstanceWithResultRequest, global::GatewayProtocol.CreateProcessInstanceWithResultResponse>(serviceImpl.CreateProcessInstanceWithResult));
      serviceBinder.AddMethod(__Method_DeployProcess, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::GatewayProtocol.DeployProcessRequest, global::GatewayProtocol.DeployProcessResponse>(serviceImpl.DeployProcess));
      serviceBinder.AddMethod(__Method_DeployResource, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::GatewayProtocol.DeployResourceRequest, global::GatewayProtocol.DeployResourceResponse>(serviceImpl.DeployResource));
      serviceBinder.AddMethod(__Method_FailJob, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::GatewayProtocol.FailJobRequest, global::GatewayProtocol.FailJobResponse>(serviceImpl.FailJob));
      serviceBinder.AddMethod(__Method_ThrowError, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::GatewayProtocol.ThrowErrorRequest, global::GatewayProtocol.ThrowErrorResponse>(serviceImpl.ThrowError));
      serviceBinder.AddMethod(__Method_PublishMessage, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::GatewayProtocol.PublishMessageRequest, global::GatewayProtocol.PublishMessageResponse>(serviceImpl.PublishMessage));
      serviceBinder.AddMethod(__Method_ResolveIncident, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::GatewayProtocol.ResolveIncidentRequest, global::GatewayProtocol.ResolveIncidentResponse>(serviceImpl.ResolveIncident));
      serviceBinder.AddMethod(__Method_SetVariables, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::GatewayProtocol.SetVariablesRequest, global::GatewayProtocol.SetVariablesResponse>(serviceImpl.SetVariables));
      serviceBinder.AddMethod(__Method_Topology, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::GatewayProtocol.TopologyRequest, global::GatewayProtocol.TopologyResponse>(serviceImpl.Topology));
      serviceBinder.AddMethod(__Method_UpdateJobRetries, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::GatewayProtocol.UpdateJobRetriesRequest, global::GatewayProtocol.UpdateJobRetriesResponse>(serviceImpl.UpdateJobRetries));
      serviceBinder.AddMethod(__Method_ModifyProcessInstance, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::GatewayProtocol.ModifyProcessInstanceRequest, global::GatewayProtocol.ModifyProcessInstanceResponse>(serviceImpl.ModifyProcessInstance));
    }

  }
}
#endregion
